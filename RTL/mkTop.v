//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
// On Sat Sep 10 00:56:41 CEST 2022
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTop(CLK,
	     RST_N);
  input  CLK;
  input  RST_N;

  // register cycles
  reg [15 : 0] cycles;
  wire [15 : 0] cycles$D_IN;
  wire cycles$EN;

  // register xs_0
  reg [3 : 0] xs_0;
  wire [3 : 0] xs_0$D_IN;
  wire xs_0$EN;

  // register xs_1
  reg [3 : 0] xs_1;
  wire [3 : 0] xs_1$D_IN;
  wire xs_1$EN;

  // register xs_2
  reg [3 : 0] xs_2;
  wire [3 : 0] xs_2$D_IN;
  wire xs_2$EN;

  // register xs_3
  reg [3 : 0] xs_3;
  wire [3 : 0] xs_3$D_IN;
  wire xs_3$EN;

  // register xs_4
  reg [3 : 0] xs_4;
  wire [3 : 0] xs_4$D_IN;
  wire xs_4$EN;

  // register xs_5
  reg [3 : 0] xs_5;
  wire [3 : 0] xs_5$D_IN;
  wire xs_5$EN;

  // register xs_6
  reg [3 : 0] xs_6;
  wire [3 : 0] xs_6$D_IN;
  wire xs_6$EN;

  // register xs_7
  reg [3 : 0] xs_7;
  wire [3 : 0] xs_7$D_IN;
  wire xs_7$EN;

  // register xs_8
  reg [3 : 0] xs_8;
  wire [3 : 0] xs_8$D_IN;
  wire xs_8$EN;

  // register xs_9
  reg [3 : 0] xs_9;
  wire [3 : 0] xs_9$D_IN;
  wire xs_9$EN;

  // ports of submodule dut
  wire [39 : 0] dut$get;
  wire [3 : 0] dut$ae_1;
  wire dut$EN_ae;

  // rule scheduling signals
  wire CAN_FIRE_RL_drive_input,
       CAN_FIRE_RL_finish,
       WILL_FIRE_RL_drive_input,
       WILL_FIRE_RL_finish;

  // submodule dut
  mkAercounter dut(.CLK(CLK),
		   .RST_N(RST_N),
		   .ae_1(dut$ae_1),
		   .EN_ae(dut$EN_ae),
		   .RDY_ae(),
		   .get(dut$get),
		   .RDY_get());

  // rule RL_finish
  assign CAN_FIRE_RL_finish = cycles == 16'd64 ;
  assign WILL_FIRE_RL_finish = CAN_FIRE_RL_finish ;

  // rule RL_drive_input
  assign CAN_FIRE_RL_drive_input = 1'd1 ;
  assign WILL_FIRE_RL_drive_input = 1'd1 ;

  // register cycles
  assign cycles$D_IN = cycles + 16'd1 ;
  assign cycles$EN = 1'd1 ;

  // register xs_0
  assign xs_0$D_IN = 4'h0 ;
  assign xs_0$EN = 1'b0 ;

  // register xs_1
  assign xs_1$D_IN = 4'h0 ;
  assign xs_1$EN = 1'b0 ;

  // register xs_2
  assign xs_2$D_IN = 4'h0 ;
  assign xs_2$EN = 1'b0 ;

  // register xs_3
  assign xs_3$D_IN = 4'h0 ;
  assign xs_3$EN = 1'b0 ;

  // register xs_4
  assign xs_4$D_IN = 4'h0 ;
  assign xs_4$EN = 1'b0 ;

  // register xs_5
  assign xs_5$D_IN = 4'h0 ;
  assign xs_5$EN = 1'b0 ;

  // register xs_6
  assign xs_6$D_IN = 4'h0 ;
  assign xs_6$EN = 1'b0 ;

  // register xs_7
  assign xs_7$D_IN = 4'h0 ;
  assign xs_7$EN = 1'b0 ;

  // register xs_8
  assign xs_8$D_IN = 4'h0 ;
  assign xs_8$EN = 1'b0 ;

  // register xs_9
  assign xs_9$D_IN = 4'h0 ;
  assign xs_9$EN = 1'b0 ;

  // submodule dut
  assign dut$ae_1 = cycles[7:4] ;
  assign dut$EN_ae = 1'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cycles <= `BSV_ASSIGNMENT_DELAY 16'd0;
	xs_0 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_1 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_2 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_3 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_4 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_5 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_6 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_7 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_8 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	xs_9 <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (cycles$EN) cycles <= `BSV_ASSIGNMENT_DELAY cycles$D_IN;
	if (xs_0$EN) xs_0 <= `BSV_ASSIGNMENT_DELAY xs_0$D_IN;
	if (xs_1$EN) xs_1 <= `BSV_ASSIGNMENT_DELAY xs_1$D_IN;
	if (xs_2$EN) xs_2 <= `BSV_ASSIGNMENT_DELAY xs_2$D_IN;
	if (xs_3$EN) xs_3 <= `BSV_ASSIGNMENT_DELAY xs_3$D_IN;
	if (xs_4$EN) xs_4 <= `BSV_ASSIGNMENT_DELAY xs_4$D_IN;
	if (xs_5$EN) xs_5 <= `BSV_ASSIGNMENT_DELAY xs_5$D_IN;
	if (xs_6$EN) xs_6 <= `BSV_ASSIGNMENT_DELAY xs_6$D_IN;
	if (xs_7$EN) xs_7 <= `BSV_ASSIGNMENT_DELAY xs_7$D_IN;
	if (xs_8$EN) xs_8 <= `BSV_ASSIGNMENT_DELAY xs_8$D_IN;
	if (xs_9$EN) xs_9 <= `BSV_ASSIGNMENT_DELAY xs_9$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cycles = 16'hAAAA;
    xs_0 = 4'hA;
    xs_1 = 4'hA;
    xs_2 = 4'hA;
    xs_3 = 4'hA;
    xs_4 = 4'hA;
    xs_5 = 4'hA;
    xs_6 = 4'hA;
    xs_7 = 4'hA;
    xs_8 = 4'hA;
    xs_9 = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_finish) $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      $display("[%0d] counter=%16h", $unsigned(cycles), dut$get);
  end
  // synopsys translate_on
endmodule  // mkTop

