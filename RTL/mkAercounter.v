//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
// On Sat Sep 10 00:56:41 CEST 2022
//
//
// Ports:
// Name                         I/O  size props
// RDY_ae                         O     1 const
// get                            O    40 reg
// RDY_get                        O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ae_1                           I     4
// EN_ae                          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAercounter(CLK,
		    RST_N,

		    ae_1,
		    EN_ae,
		    RDY_ae,

		    get,
		    RDY_get);
  input  CLK;
  input  RST_N;

  // action method ae
  input  [3 : 0] ae_1;
  input  EN_ae;
  output RDY_ae;

  // value method get
  output [39 : 0] get;
  output RDY_get;

  // signals for module outputs
  wire [39 : 0] get;
  wire RDY_ae, RDY_get;

  // register counters_0
  reg [3 : 0] counters_0;
  wire [3 : 0] counters_0$D_IN;
  wire counters_0$EN;

  // register counters_1
  reg [3 : 0] counters_1;
  wire [3 : 0] counters_1$D_IN;
  wire counters_1$EN;

  // register counters_2
  reg [3 : 0] counters_2;
  wire [3 : 0] counters_2$D_IN;
  wire counters_2$EN;

  // register counters_3
  reg [3 : 0] counters_3;
  wire [3 : 0] counters_3$D_IN;
  wire counters_3$EN;

  // register counters_4
  reg [3 : 0] counters_4;
  wire [3 : 0] counters_4$D_IN;
  wire counters_4$EN;

  // register counters_5
  reg [3 : 0] counters_5;
  wire [3 : 0] counters_5$D_IN;
  wire counters_5$EN;

  // register counters_6
  reg [3 : 0] counters_6;
  wire [3 : 0] counters_6$D_IN;
  wire counters_6$EN;

  // register counters_7
  reg [3 : 0] counters_7;
  wire [3 : 0] counters_7$D_IN;
  wire counters_7$EN;

  // register counters_8
  reg [3 : 0] counters_8;
  wire [3 : 0] counters_8$D_IN;
  wire counters_8$EN;

  // register counters_9
  reg [3 : 0] counters_9;
  wire [3 : 0] counters_9$D_IN;
  wire counters_9$EN;

  // rule scheduling signals
  wire CAN_FIRE_ae, WILL_FIRE_ae;

  // remaining internal signals
  reg [3 : 0] SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13;

  // action method ae
  assign RDY_ae = 1'd1 ;
  assign CAN_FIRE_ae = 1'd1 ;
  assign WILL_FIRE_ae = EN_ae ;

  // value method get
  assign get =
	     { counters_9,
	       counters_8,
	       counters_7,
	       counters_6,
	       counters_5,
	       counters_4,
	       counters_3,
	       counters_2,
	       counters_1,
	       counters_0 } ;
  assign RDY_get = 1'd1 ;

  // register counters_0
  assign counters_0$D_IN =
	     SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 + 4'd1 ;
  assign counters_0$EN = EN_ae && ae_1 == 4'd0 ;

  // register counters_1
  assign counters_1$D_IN = counters_0$D_IN ;
  assign counters_1$EN = EN_ae && ae_1 == 4'd1 ;

  // register counters_2
  assign counters_2$D_IN = counters_0$D_IN ;
  assign counters_2$EN = EN_ae && ae_1 == 4'd2 ;

  // register counters_3
  assign counters_3$D_IN = counters_0$D_IN ;
  assign counters_3$EN = EN_ae && ae_1 == 4'd3 ;

  // register counters_4
  assign counters_4$D_IN = counters_0$D_IN ;
  assign counters_4$EN = EN_ae && ae_1 == 4'd4 ;

  // register counters_5
  assign counters_5$D_IN = counters_0$D_IN ;
  assign counters_5$EN = EN_ae && ae_1 == 4'd5 ;

  // register counters_6
  assign counters_6$D_IN = counters_0$D_IN ;
  assign counters_6$EN = EN_ae && ae_1 == 4'd6 ;

  // register counters_7
  assign counters_7$D_IN = counters_0$D_IN ;
  assign counters_7$EN = EN_ae && ae_1 == 4'd7 ;

  // register counters_8
  assign counters_8$D_IN = counters_0$D_IN ;
  assign counters_8$EN = EN_ae && ae_1 == 4'd8 ;

  // register counters_9
  assign counters_9$D_IN = counters_0$D_IN ;
  assign counters_9$EN = EN_ae && ae_1 == 4'd9 ;

  // remaining internal signals
  always@(ae_1 or
	  counters_0 or
	  counters_1 or
	  counters_2 or
	  counters_3 or
	  counters_4 or
	  counters_5 or counters_6 or counters_7 or counters_8 or counters_9)
  begin
    case (ae_1)
      4'd0:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_0;
      4'd1:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_1;
      4'd2:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_2;
      4'd3:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_3;
      4'd4:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_4;
      4'd5:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_5;
      4'd6:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_6;
      4'd7:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_7;
      4'd8:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_8;
      4'd9:
	  SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
	      counters_9;
      default: SEL_ARR_counters_0_counters_1_counters_2_count_ETC___d13 =
		   4'b1010 /* unspecified value */ ;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        counters_0 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_1 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_2 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_3 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_4 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_5 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_6 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_7 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_8 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	counters_9 <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (counters_0$EN)
	  counters_0 <= `BSV_ASSIGNMENT_DELAY counters_0$D_IN;
	if (counters_1$EN)
	  counters_1 <= `BSV_ASSIGNMENT_DELAY counters_1$D_IN;
	if (counters_2$EN)
	  counters_2 <= `BSV_ASSIGNMENT_DELAY counters_2$D_IN;
	if (counters_3$EN)
	  counters_3 <= `BSV_ASSIGNMENT_DELAY counters_3$D_IN;
	if (counters_4$EN)
	  counters_4 <= `BSV_ASSIGNMENT_DELAY counters_4$D_IN;
	if (counters_5$EN)
	  counters_5 <= `BSV_ASSIGNMENT_DELAY counters_5$D_IN;
	if (counters_6$EN)
	  counters_6 <= `BSV_ASSIGNMENT_DELAY counters_6$D_IN;
	if (counters_7$EN)
	  counters_7 <= `BSV_ASSIGNMENT_DELAY counters_7$D_IN;
	if (counters_8$EN)
	  counters_8 <= `BSV_ASSIGNMENT_DELAY counters_8$D_IN;
	if (counters_9$EN)
	  counters_9 <= `BSV_ASSIGNMENT_DELAY counters_9$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counters_0 = 4'hA;
    counters_1 = 4'hA;
    counters_2 = 4'hA;
    counters_3 = 4'hA;
    counters_4 = 4'hA;
    counters_5 = 4'hA;
    counters_6 = 4'hA;
    counters_7 = 4'hA;
    counters_8 = 4'hA;
    counters_9 = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkAercounter

